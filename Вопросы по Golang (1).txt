

==============================
    Мапа
==============================
Часто
-------------
    - Что такое мапа?
    Это встроенный тип данных, который представляет собой коллекцию пар "ключ-значение"

Средне
-------------
    - Что произойдет при конкуррентной записи в мапу?
    При конкуррентной (параллельной) записи в мапу из нескольких горутин может возникнуть состояние гонки,
    что приведет к неопределенному поведению программы. Это может вызвать панику. Чтобы избежать проблем с конкуррентным
    доступом к мапе, можно использовать sync.Mutex или sync.Map
    - Как устроена мапа под капотом?
    Основные компоненты мапы в Go
    Хэш-функция:
    Каждый ключ в мапе преобразуется в хэш (целое число) с помощью хэш-функции.
    Хэш-функция должна быть быстрой и равномерно распределять ключи по хэш-таблице, чтобы минимизировать коллизии.
    Бакеты (buckets):
    Мапа в Go состоит из массива бакетов. Каждый бакет содержит несколько пар "ключ-значение".
    Количество бакетов всегда является степенью двойки (например, 8, 16, 32 и т.д.), что позволяет использовать побитовые
    операции для быстрого вычисления индекса бакета.
    Хэш-таблица:
    Хэш-таблица — это массив бакетов. Каждый бакет содержит:
    Массив ключей.
    Массив значений.
    Указатель на следующий бакет (для разрешения коллизий методом цепочек).
    Коллизии:
    Коллизия возникает, когда два разных ключа имеют одинаковый хэш и попадают в один и тот же бакет.
    В Go коллизии разрешаются с помощью метода цепочек (chaining): если бакет переполняется, создается новый бакет, который связывается с текущим.
    Как работает мапа
    Добавление элемента:
    Вычисляется хэш ключа.
    По хэшу определяется индекс бакета в хэш-таблице.
    Если бакет уже содержит элементы, происходит проверка на коллизии. Если ключ уже существует, значение обновляется.
    Если ключ новый, он добавляется в бакет.
    Получение элемента:
    Вычисляется хэш ключа.
    По хэшу определяется индекс бакета.
    В бакете ищется ключ. Если ключ найден, возвращается соответствующее значение. Если ключ не найден, возвращается нулевое значение для типа значения.
    Удаление элемента:
    Вычисляется хэш ключа.
    По хэшу определяется индекс бакета.
    В бакете ищется ключ. Если ключ найден, он удаляется из бакета.
    Динамическое расширение мапы
    Когда мапа становится слишком заполненной (например, количество элементов превышает определенный порог), Go автоматически
    увеличивает размер хэш-таблицы. Это называется рехэшированием (rehashing):
    Создается новая хэш-таблица с большим количеством бакетов.
    Все существующие элементы пересчитываются и перемещаются в новую хэш-таблицу.
    Старая хэш-таблица удаляется.
    - Какие ключи могут быть у мапы?
    В Go ключи мапы (map) могут быть любого типа, для которого определена операция сравнения на равенство (==).
    Типы, которые могут быть ключами мапы: базовые типы (int, int8, int16, int32, int64, uint, uint8, uint16, uint32, uint64,
    float32, float64, complex64, complex128, string, bool), указатели на сравниваемые типы, каналы, интерфейсы (если их
    динамические значения сравнимы), структуры (если все их поля сравнимы), массивы (если их элементы сравнимы).
    - Какая сложность работы с мапой?
    Сложность (временная и пространственная) работы с мапой в Go зависит от операций, которые вы выполняете.
    Вставка (добавление или обновление элемента):
    В среднем: O(1).
    В худшем случае: O(n), где n — количество элементов в мапе. Это происходит при большом количестве коллизий,
    когда все элементы попадают в один бакет, и мапе приходится выполнять рехэширование.
    Поиск (получение элемента по ключу):
    В среднем: O(1).
    В худшем случае: O(n), если все элементы попадают в один бакет (крайне редкая ситуация при хорошей хэш-функции).
    Удаление элемента:
    В среднем: O(1).
    В худшем случае: O(n), если все элементы попадают в один бакет.
    Итерация по мапе:
    Временная сложность: O(n), где n — количество элементов в мапе.
    Пространственная сложность: O(1), так как итерация не требует дополнительной памяти.
    - Можно ли взять адрес элемента мапы и почему?
    В Go нельзя взять адрес элемента мапы, так как мапа — это динамическая структура данных, и её элементы могут быть перемещены
    в памяти при изменении мапы. Это ограничение помогает избежать ошибок, связанных с изменением мапы, и делает поведение программы более предсказуемым.
    Если нужно изменять значения в мапе, можно использовать указатели или копирование значений.
    - Как работает эвакуация данных?
    Эвакуация данных (evacuation) в мапе Go — это процесс перераспределения элементов мапы при её расширении (рехэшировании).
    Как работает эвакуация данных?
    Инициализация новой хэш-таблицы:
    Создается новая хэш-таблица с большим количеством бакетов (обычно в 2 раза больше, чем в старой таблице).
    Постепенная эвакуация:
    Эвакуация выполняется постепенно, чтобы не блокировать работу с мапой на долгое время.
    Go использует фоновую эвакуацию: элементы перемещаются из старой хэш-таблицы в новую по мере обращения к мапе.
    Пересчет индексов бакетов:
    Для каждого элемента вычисляется новый индекс бакета в новой хэш-таблице. Это делается с помощью той же хэш-функции, но с учетом нового количества бакетов.
    Перемещение элементов:
    Элементы из старой хэш-таблицы перемещаются в новую. Если в новом бакете уже есть элементы, они связываются в цепочку (метод цепочек).
    Очистка старой хэш-таблицы:
    После завершения эвакуации старая хэш-таблица удаляется.

Редко
-------------
    - Как разрешаются коллизии в мапе?
    В Go используется метод цепочек (chaining). Вот как это работает:
    Каждый бакет содержит массив пар "ключ-значение":
    Каждый бакет может хранить несколько пар "ключ-значение". В Go каждый бакет может содержать до 8 пар.
    Если бакет переполняется, создается новый бакет:
    Если в бакете уже есть 8 пар, и добавляется новая пара, создается новый бакет, который связывается с текущим. Это называется цепочкой (chain).
    Поиск в цепочке:
    При поиске элемента сначала вычисляется хэш ключа, определяется бакет, а затем выполняется поиск по цепочке (если она есть).
    - Как сделать конкурентную запись в мапу?
    sync.Mutex или sync.RWMutex для простых случаев.
    sync.Map для высоконагруженных приложений.
    Каналы для сложных сценариев с централизованным управлением доступом.
    - Как достигается константная сложность работы с мапой?
    Константная сложность (O(1)) работы с мапой в Go достигается благодаря:
    Использованию хэш-таблицы.
    Хорошей хэш-функции, равномерно распределяющей ключи по бакетам.
    Методу цепочек для разрешения коллизий.
    Динамическому расширению мапы при увеличении количества элементов.
    - В функции make для мапы мы указываем число. Что оно дает?
    Это предполагаемое количество элементов, которые будут храниться в мапе. Это не жесткое ограничение, а лишь подсказка для Go,
    чтобы выделить достаточно памяти заранее.
    - Для чего используется мапа?
    Основные сценарии использования мапы
    Хранение данных по ключу:
    Мапа позволяет хранить данные в виде пар "ключ-значение". Это полезно, когда вам нужно быстро находить значение по уникальному ключу.
    Подсчет частоты элементов:
    Мапа часто используется для подсчета частоты элементов в коллекции.
    Кэширование данных:
    Мапа может использоваться для кэширования результатов вычислений или запросов к базе данных, чтобы избежать повторных вычислений или запросов.
    Группировка данных:
    Мапа позволяет группировать данные по определенному признаку.
    Реализация множеств (sets):
    В Go нет встроенного типа "множество", но его можно эмулировать с помощью мапы, где ключи — это элементы множества,
    а значения — пустые структуры (или bool).
    Конфигурации и настройки:
    Мапа может использоваться для хранения конфигураций или настроек, где ключи — это названия параметров, а значения — их значения.
    Реализация словарей:
    Мапа может использоваться для реализации словарей, где ключи — это слова, а значения — их определения или переводы.
    - Мапа потокобезопасная?
    Нет, мапа (map) в Go не является потокобезопасной (not thread-safe). Это означает, что одновременный доступ к мапе из нескольких горутин
    без синхронизации может привести к состоянию гонки и неопределенному поведению программы, включая панику.
    - Пробовали из разных потоков писать в мапу?
    Да, например мапа использовалась в моем проекте в пакете базы данных для получения и хранения записей. Для решения многопоточности я использовала мьютекс.
    - Стало слишком много коллизий в мапе, как решить проблему?
    Увеличение количества бакетов
    Go автоматически увеличивает количество бакетов в мапе, когда она становится слишком заполненной. Однако можно помочь этому процессу,
    указав предполагаемую ёмкость мапы при её создании.
    Использование лучшей хэш-функции
    Хэш-функция в Go встроена и оптимизирована для большинства сценариев. Однако если вы используете пользовательские типы в качестве ключей,
    убедитесь, что ваша хэш-функция равномерно распределяет ключи по бакетам.
    Уменьшение нагрузки на мапу
    Если мапа становится слишком "плотной" (много коллизий), можно уменьшить нагрузку, удалив ненужные элементы или разделив данные на несколько мап.
    Использование sync.Map
    Если вы работаете с высоконагруженной мапой в многопоточной среде, рассмотрите использование sync.Map. Он оптимизирован для случаев, когда ключи
    часто читаются, но редко записываются.
    Переход на другую структуру данных
    Если мапа не подходит для вашего сценария (например, из-за частых коллизий), рассмотрите использование других структур данных, таких как:
    Слайс (slice): Если ключи — это целые числа.
    Дерево (tree): Если требуется упорядоченность.
    База данных: Если данных слишком много для хранения в памяти.
    - Какая сложность работы с мапой в худшем случае?
    В худшем случае сложность работы с мапой (map) в Go может достигать O(n), где n — количество элементов в мапе.
    Почему в худшем случае O(n)?
    Мапа в Go реализована как хэш-таблица, и её производительность зависит от равномерного распределения ключей по бакетам.
    В идеальном случае (мало коллизий) сложность операций (вставка, поиск, удаление) составляет O(1). Однако в худшем случае:
    Все ключи попадают в один бакет:
    Если хэш-функция возвращает одинаковый хэш для всех ключей, все элементы будут храниться в одном бакете.
    В этом случае мапа вырождается в связный список, и операции требуют обхода всех элементов.
    Длина цепочки становится O(n):
    Если в одном бакете хранится n элементов, то для поиска, вставки или удаления элемента потребуется обойти все n элементов.
    - Что произойдет при конкуррентном чтении из мапы?
    В Go мапа (map) не является потокобезопасной (not thread-safe). Это означает, что конкуррентное (параллельное) чтение из мапы
    без синхронизации может привести к неопределенному поведению, если одновременно с чтением происходит запись. Однако,
    если только чтение выполняется из нескольких горутин, это безопасно.
    - Чем мапа отличается от sync.Map?
    *Потокобезопасность
    Мапа (map):
    Не является потокобезопасной.
    Если несколько горутин одновременно читают и пишут в мапу, это может привести к состоянию гонки (race condition) и панике.
    Для безопасного использования в многопоточной среде требуется синхронизация (например, с помощью sync.Mutex или sync.RWMutex).
    sync.Map:
    Потокобезопасна.
    Предоставляет встроенные методы для безопасного использования в многопоточной среде.
    Не требует дополнительной синхронизации.
    *Производительность
    Мапа (map):
    Оптимизирована для однопоточного использования.
    В среднем операции (вставка, поиск, удаление) выполняются за O(1).
    В многопоточной среде требует использования мьютексов, что может снизить производительность.
    sync.Map:
    Оптимизирована для многопоточных сценариев, где ключи часто читаются, но редко записываются.
    Вставка, поиск и удаление могут быть медленнее, чем у обычной мапы, из-за накладных расходов на синхронизацию.
    Подходит для сценариев с высокой конкуренцией за чтение.
    *API
    Мапа (map):
    Использует стандартный синтаксис для работы с ключами и значениями
    sync.Map:
    Использует методы для работы с ключами и значениями
    *Типы ключей и значений
    Мапа (map):
    Ключи и значения могут быть любого типа, для которого определена операция сравнения на равенство (==).
    sync.Map:
    Ключи и значения имеют тип interface{}, что позволяет использовать любые типы.
    *Итерация
    Мапа (map):
    Итерация выполняется с помощью цикла for range
    Порядок итерации не гарантируется.
    sync.Map:
    Итерация выполняется с помощью метода Range
    *Использование памяти
    Мапа (map):
    Использует меньше памяти, чем sync.Map, так как не имеет накладных расходов на синхронизацию.
    sync.Map:
    Использует больше памяти из-за внутренних структур для обеспечения потокобезопасности.
    **Когда использовать мапу, а когда sync.Map?
    Используйте мапу (map), если:
    Вы работаете в однопоточном режиме.
    Вам нужна максимальная производительность.
    Вы готовы самостоятельно управлять синхронизацией (например, с помощью sync.Mutex).
    Используйте sync.Map, если:
    Вы работаете в многопоточной среде.
    Ключи часто читаются, но редко записываются.
    Вам нужна встроенная потокобезопасность без необходимости использовать мьютексы.


==============================
    Массивы/Слайсы
==============================
Часто
-------------
    - Что такое слайс?
    Слайс (slice) — это динамическая структура данных, которая представляет собой последовательность элементов одного типа.
    Слайс является более гибкой и мощной версией массива, так как он может изменять свой размер во время выполнения программы.
    - Чем массив отличается от слайса?
    *Размер
    Массив:
    Имеет фиксированный размер, который задается при объявлении и не может быть изменен во время выполнения программы.
    Слайс:
    Имеет динамический размер, который может изменяться во время выполнения программы.
    *Передача в функции
    Массив:
    Передается по значению. Это означает, что при передаче массива в функцию создается его копия, и изменения внутри функции
    не влияют на оригинальный массив.
    Слайс:
    Передается по ссылке. Слайс содержит указатель на массив, поэтому изменения внутри функции влияют на оригинальный слайс.
    *Инициализация
    Массив:
    Размер должен быть указан явно при объявлении.
    Слайс:
    Размер не указывается явно. Слайс может быть создан пустым или с начальными значениями.
    *Емкость (capacity)
    Массив:
    Емкость массива всегда равна его размеру и не может быть изменена.
    Слайс:
    Емкость слайса может быть больше его длины, что позволяет добавлять элементы без выделения новой памяти.
    * Изменение размера
    Массив:
    Размер массива нельзя изменить после его создания.
    Слайс:
    Размер слайса можно изменить с помощью функции append.
    *Тип
    Массив:
    Тип массива включает его размер. Например, [3]int и [5]int — это разные типы.
    Слайс:
    Тип слайса не включает его размер. Все слайсы одного типа элементов ([]int, []string) считаются одинаковыми.
    * Использование в реальных задачах
    Массив:
    Используется реже, так как его фиксированный размер ограничивает гибкость.
    Подходит для случаев, когда размер данных известен заранее и не изменяется.
    Слайс:
    Используется чаще, так как он более гибкий и удобный для работы с динамическими данными.
    Подходит для большинства задач, где требуется работать с последовательностями данных.

Средне
-------------
    - Как работает append?
    append добавляет элементы в слайс. Если в слайсе достаточно места (емкость позволяет), элементы добавляются в существующий массив.
    Если места нет, Go выделяет новый массив с увеличенной емкостью (обычно в 2 раза больше), копирует туда старые элементы, добавляет
    новые и возвращает новый слайс. Всегда нужно присваивать результат append обратно в переменную, так как слайс может измениться.
    Амортизированная сложность — O(1), благодаря экспоненциальному росту емкости.

Редко
-------------
    - Как правильно/неправильно работать со слайсом?
    - Для чего можно использовать массивы в Golang?
    Массивы в Go используются, когда размер данных фиксирован и известен заранее. Например:
    Для хранения статических структур (координаты, матрицы).
    Когда нужна предсказуемость и эффективность по памяти.
    Для ключей в map, так как массивы поддерживают сравнение по значению.
    В низкоуровневых операциях (работа с бинарными данными, заголовками).
    - До какого размера можно увеличивать слайс?
    Теоретически слайс можно увеличивать до максимального значения int, ограниченного архитектурой системы.
    На практике размер слайса ограничен доступной памятью и производительностью.
    При работе с очень большими слайсами важно учитывать затраты на память и время копирования данных.
    - Допустима ли конкуррентная работа со слайсом?
    Конкурентная работа со слайсом без синхронизации недопустима.
    Для безопасной работы можно использовать:
    sync.Mutex для блокировки доступа.
    Каналы для передачи данных между горутинами.
    sync.WaitGroup для ожидания завершения горутин.
    Если требуется частое изменение слайса, можно использовать специализированные потокобезопасные структуры, например,
    из пакета sync/atomic или сторонних библиотек.
    (Так же всегда проверять код на наличие гонок с помощью go run -race)
    - Для чего используются слайсы?
   Слайсы используются для работы с коллекциями данных, когда размер может изменяться. Они гибче массивов, так как могут расти
     или уменьшаться с помощью append.
     Основные сценарии использования:
     Динамические данные: Когда количество элементов заранее неизвестно.
     Работа с подмножествами: Срезы позволяют брать часть слайса без копирования.
     Эффективность: Слайсы передаются по ссылке, что экономит память.
     Структуры данных: Слайсы легко адаптируются для стеков, очередей.
     Работа с файлами/сетью: Чтение и запись данных.
     Сортировка и поиск: Интеграция с пакетом sort.
     JSON и сериализация: Удобно для работы с форматами данных.
    - Берем от слайса слайс, куда будет указывать его указатель?
    Когда мы берем слайс от слайса, новый слайс указывает на тот же массив, что и исходный, но только на его часть.
    Это позволяет эффективно работать с подмножествами данных, но требует осторожности, так как изменения в одном слайсе могут повлиять на другой.
    - В чем разница между слайсом указателей и слайсом значений с точки зрения вызова функции?
    Слайс значений
    Передается копия заголовка, но данные изменяются в оригинальном массиве.
    Слайс указателей
    Передается копия заголовка, но изменяются данные по указателям.
    Выбор зависит от задачи: если нужно изменять данные — слайс значений; если нужно избежать копирования или работать с nil — слайс указателей.
    - Где в памяти размещается массив, а где слайс?
Массив:
Хранится в стеке (если локальный и небольшой) или в куче (если динамический или часть структуры).
Фиксированный размер.
Слайс:
Заголовок слайса (указатель, длина, емкость) хранится в стеке.
Данные слайса (массив) всегда хранятся в куче.
    - Какие методы оптимизации работы со слайсами ты бы применил в работе?
    Для оптимизации работы со слайсами в Go я бы использовала следующие подходы:
    Предварительное выделение памяти через make с указанием емкости, чтобы избежать частых переаллокаций при использовании append.
    Минимизация копирования данных: вместо присваивания слайсов использовал бы copy, чтобы создавать независимые копии.
    Использование срезов для работы с подмножествами данных без копирования.
    Избежание частых вызовов append в циклах: заранее выделял бы память, чтобы уменьшить количество переаллокаций.
    Передача больших слайсов по указателю в функции, чтобы избежать копирования заголовка слайса.
    Использование sync.Pool для слайсов, которые часто создаются и удаляются, чтобы снизить нагрузку на сборщик мусора.
    Очистка слайсов перед повторным использованием, чтобы избежать лишних аллокаций.
    Проверка емкости перед добавлением элементов, чтобы избежать неожиданных переаллокаций.
    Эти методы помогают улучшить производительность и эффективность работы со слайсами, особенно при работе с большими объемами данных.
    (Аллокация — это выделение памяти для данных (например, для слайса или массива).
     Переаллокация — это процесс выделения нового блока памяти большего размера и копирования туда данных, когда текущей памяти
     недостаточно)
    - Какие есть ограничения при работе со слайсом?
    Изменение исходного массива: Слайсы ссылаются на базовый массив, поэтому изменение одного слайса может повлиять на другие,
    если они используют тот же массив.
    Утечки памяти: Если слайс ссылается на большой массив, даже маленький срез может удерживать весь массив в памяти.
     Чтобы избежать этого, можно использовать copy для создания независимого слайса.
    Переаллокации при append: Если емкость слайса недостаточна, append выделяет новый массив и копирует данные. Это можно
    минимизировать, предварительно выделяя память через make с указанием емкости.
    Ошибки индексации: Доступ к элементам за пределами длины слайса вызывает панику. Всегда нужно проверять длину перед доступом.
    Сравнение слайсов: Слайсы нельзя сравнивать напрямую через ==. Для сравнения можно использовать reflect.DeepEqual.
    Конкурентный доступ: Слайсы не потокобезопасны. Для работы с ними в многопоточной среде нужно использовать мьютексы или каналы.
    Передача в функции: Слайсы передаются по значению (копируется заголовок), но данные остаются общими. Если нужно избежать изменений, можно передавать слайс по указателю или создавать копию.
    - Какие есть средства для добавления элементов в слайс?
    Основное средство для добавления элементов в слайс в Go — это функция append. Она позволяет добавлять один или несколько
    элементов в конец слайса и автоматически увеличивает его емкость, если это необходимо.
    Если нужно добавить элементы из другого слайса, можно использовать append с оператором ...
    Для оптимизации можно заранее выделить память с помощью make, чтобы избежать переаллокаций
    В высокопроизводительных сценариях можно использовать sync.Pool для повторного использования слайсов и уменьшения нагрузки на сборщик мусора.
    - Какая есть функции для создания слайса с длиной отличной от нуля?
    make([]T, length) — создает слайс с заданной длиной.
    Инициализация с элементами — []T{...}.
    Создание из массива — arr[:].
    Использование append — добавление элементов в пустой слайс.
    Копирование данных — copy.
    - С какой скоростью идет поиск в массиве и почему?
    Линейный поиск в массиве имеет сложность O(n), так как нужно проверить каждый элемент.
    Если массив отсортирован, можно использовать бинарный поиск со сложностью O(log n).
    Бинарный поиск:
    Делит массив на две части.
    Сравнивает искомый элемент с элементом в середине массива.
    Если элемент не найден, поиск продолжается в одной из половин.
    - Чем хорош массив по сравнению со слайсом?
    Фиксированный размер: Массивы имеют фиксированный размер, который задается на этапе компиляции. Это делает их предсказуемыми
    и безопасными, когда размер данных известен заранее.
    Эффективность по памяти: Массивы хранят данные непосредственно в своей структуре, без накладных расходов на заголовок,
    как у слайсов. Это делает их более эффективными для небольших и статических данных.
    Быстрый доступ к элементам: Доступ к элементам массива происходит за O(1), так как массив — это непрерывный блок памяти.
    Это полезно для задач, где важна скорость доступа.
    Безопасность: Массивы не могут быть изменены по размеру, что исключает риск переаллокаций или утечек памяти. Это делает
    их более безопасными в многопоточных приложениях.
    Передача по значению: Массивы передаются в функции по значению, то есть создается копия. Это полезно, если нужно гарантировать,
     что исходные данные не изменятся.
    Использование как ключи в мапах: Массивы можно использовать как ключи в мапах, так как они поддерживают сравнение по значению.
    Слайсы, напротив, нельзя использовать как ключи.
    - Что такое массив?
    Массив в Go — это структура данных, которая представляет собой фиксированную последовательность элементов одного типа. Массив имеет
    строго определенный размер, который задается на этапе компиляции и не может быть изменен во время выполнения программы.


==============================
    Каналы
==============================
Часто
-------------
    - Что такое каналы?

Средне
-------------
    - Как устроен канал и как он работает под капотом?
    - Какие есть типы каналов в Golang?
    - Что если писать/читать в закрытый канал?

Редко
-------------
    - Что будет при записи в закрытый канал?
    - Чем отличается запись/чтение в буферизованном и небуферизованном канале?
    - Что произойдет с читателями/писателями если закрыть канал?
    - Что если закрыть закрытый канал?
    - Что используется для неблокирующего чтения из канала?
    - Какие операции есть с каналами?
    - Какие параметры могут иметь каналы?
    - Для чего используется select при работе с каналами?
    - Как проверить, что канал закрыт?
    - Как сделать канал буферизованным?
    - Есть две горутины, одна пишет в небуферизованный, а другая в буферизованный канал, оба не читаются. Что произойдет?


==============================
    Примитивы синхронизации
==============================
Часто
-------------
    - Какие примитивы синхронизации есть в Golang?

Средне
-------------
    - Чем мьютекс отличается от семафора?

Редко
-------------
    - Чем мьютексы отличаются от атомиков?
    - Что из пакета sync используешь на практике?
    - Что можно использовать для ожидания выполнения N горутин?
    - Какие примитивы синхронизации использовал в работе и для чего?
    - Как устроена WaitGroup под капотом и как ее можно реализовать самому?
    - Сколько нужно ядер, чтобы начать использовать sync.Map?
    - Расскажи про sync.Map
    - Расскажи про пакет sync
    - Когда нужно использовать Mutex, а когда RWMutex?
    - Есть общий ресурс. Хотим, чтобы к нему одновременно обращались только N горутин. Как это сделать?
    - Запустим 1000 горутин с инкрементом инта. Получим в конце тысячу? Что делать, чтобы получить тысячу?
    - Есть глобальная мапа, глобальный мьютекс. Две функции. Одна блочит мьютекс, а вторая нет. Что произойдет?
    - В чем разница между Mutex и RWMutex?


==============================
    Горутины
==============================
Часто
-------------
    - Что такое горутина?
    - Чем горутина отличается от треда?

Средне
-------------
    - В чем преимущества горутин над тредами?
    - Что есть в Golang для многопоточности?

Редко
-------------
    - Зачем понадобилось добавлять горутины в Golang?
    - Как можно остановить горутину?
    - Расскажите про конкуррентность и параллельность в Golang
    - Когда возникает утечка горутины?
    - Какие есть способы связи между горутинами, какие плюсы и минусы?


==============================
    Интерфейсы
==============================
Часто
-------------
    - Что такое интерфейс?

Средне
-------------
    - Как устроен интерфейс?
    - Для чего используется интерфейс?

Редко
-------------
    - Как ты используешь интерфейс в работе?
    - Как в строготипизированным языке сделать функцию, которая работает с разными типами?
    - Зачем нужен пустой интерфейс?
    - Есть интерфейс, а есть указатель на структуру, который nil. Кладем указатель в интерфейс. Что если сравнить интерфейс с nil?
    - Чем `any` отличается от пустого интерфейса?
    - Чем пустой интерфейс отличается от пустой структуры?


==============================
    Общее
==============================

Средне
-------------
    - Какие преимущества есть у Golang?

Редко
-------------
    - Какие основные компоненты библиотеки runtime знаешь?
    - Какие недостатки есть у Golang?
    - Какие фреймворки знаешь для инициализации приложения?
    - Какая сортировка используется в Golang?
    - Какая последняя версия Golang?
    - Какая кодировка используется в Golang?
    - Расскажи про разные подходы инициализации приложения и какие сам используешь?
    - Можно ли в Golang создать статический метод?
    - Расскажи про пакет reflect и как его используешь?
    - Работали с библиотекой math? Что делает math.Pow?
    - При ручном биндинге (про инициализацию приложения) сталкивался с циклической зависимостью?
    - К каким проблемам может привести использование пакета reflect?
    - Как передаются параметры в функцию, по ссылке или по значению?
    - Для чего используется функция init?
    - В чем разница в передаче получателя метода по ссылке и по значению?
    - Вы нашли багу в Golang, вы можете как-то повлиять на исходный код, внести правки, сделать мерж реквест?
    - Чем тебе понравился Golang?
    - Что добавилось интересного с последней версией Golang?
    - Язык Golang компилируемый или интерпретируемый?


==============================
    Планировщик
==============================

Средне
-------------
    - Как работает планировщик Golang?

Редко
-------------
    - Как работает вытесняющая многозадачность?
    - За счет чего достигается параллельное выполнение в Golang? 
    - В чем разница между вытесняющим и кооперативным планировщиком? 
    - В планировщике до версии 1.15 какие операции приводят к переключению контекста горутин?
    - Можно ли руками переключить контекст горутины?
    - Может ли горутина начать работу на одном P, приостановиться и продолжить работу на другом P?
    - Может ли одна очередь украсть горутины у другой?
    - Расскажи про глобальную и локальную очереди
    - Сколько потоков операционной системы мы можем создать?
    - Какой тип планировщика в Golang?
    - Какую функцию выполняет планировщик?
    - Что происходит с горутиной при ее создании?


==============================
    Контекст
==============================
Часто
-------------
    - Для чего используется контекст?

Средне
-------------
    - Что такое контекст?

Редко
-------------
    - Как работает WithCancel?
    - Как применяешь контекст в работе?
    - Как устроен контекст?
    - Какие есть виды контекстов?
    - Перекидывали логгер в контексте?


==============================
    defer
==============================
Часто
-------------
    - Что такое defer?

Средне
-------------
    - Для чего используется defer?
    - Какой порядок выполнения нескольких defer?

Редко
-------------
    - Код в defer выполняется до return или после?
    - Где инициализируется defer, в стеке или куче?


==============================
    Память
==============================

Редко
-------------
    - В одном случае ты передаешь указатель на допустим инт, а в другом случае большую структурку. Как с точки зрения рантайма и потребления ресурсов будет вести приложение?
    - Как узнать где выделяется переменная, в стеке или куче?
    - Как можно обнаружить чересчур большое выделение памяти?
    - Предположим есть рекурсивная функция. Вызывается много раз. Что может произойти?
    - Расскажи про модель памяти в Golang, про стек и про кучу
    - Какое максимальный размер значения для размещения в стеке?
    - Что такое Escape Analysis?
    - Что если при увеличении слайса полностью забьем память?
    - Что быстрее, размещение объектов в стеке или куче и почему?
    - Что такое утечка памяти?
    - Что такое стек?


==============================
    Типы данных
==============================

Средне
-------------
    - Какие типы данных есть в Golang?

Редко
-------------
    - Какой длины руна?
    - Как реализовать Enum в Golang?
    - Если нужно в строке хранить эмодзи, то как это сделать? 
    - Что если во время компиляции переполним тип? В int8 запишем  256?
    - Что происходит при переполнении числа, например в uint8 выйдем за границу на 1?


==============================
    Гонка данных
==============================

Средне
-------------
    - Что такое race condition?
    - Как обнаружить race condition?

Редко
-------------
    - Есть глобальный слайс и я в разных горутинах присваиваю ему аппенд к нему же одного элемента. Будет ли гонка?
    - Где кроме кода может встретиться race condition?
    - Какие есть способы устранения race condition?
    - Флаг -race показывает гонку на этапе компиляции или выполнения?


==============================
    Ошибки/Паника
==============================

Редко
-------------
    - Куда нужно помещать recover?
    - Какая парадигма в Golang с точки зрения обработки исключений и ошибок?
    - Какие есть функции для оборачивания и сравнения ошибок?
    - Для чего используются ошибки, а для чего паника?
    - Для чего используется паника?
    - Есть несколько деферов, в одном из них рековер. Как будет обрабатываться паника? Что если рековер расположен сильно выше и куда бы ты его поместил в случае http вызова? Есть несколько деферов и в одном из них паника, рековер нет, что будет?
    - Что используется для обработки паники?
    - Чем отличается работа с ошибками в Golang от других языков?
    - Что такое паника?


==============================
    Указатели
==============================

Средне
-------------
    - Что такое указатель?

Редко
-------------
    - Что такое ссылка на значение?
    - Чем отличается ссылка от указателя?
    - Чем чревато передавать структуру по ссылке?
    - Для чего используются указатели?
    - Для чего в практике используешь указатели?
    - Какие есть средства для работы с указателями?
    - Когда лучше использовать/не использовать указатели?


==============================
    Дженерики
==============================

Средне
-------------
    - С дженериками работали?

Редко
-------------
    - Чем кодогенерация отличается от дженериков?
    - В какой версии появились дженерики?


==============================
    Конструкции
==============================

Редко
-------------
    - Гарантирует ли порядок выполнения конструкция select-case?
    - Как выглядит конструкция утверждения типа switch?
    - Нужно ли в switch-case проставлять break?
    - Какие есть циклы в Golang?
    - Чем отличается switch от select?


==============================
    ООП
==============================

Средне
-------------
    - Как устроено ООП в Golang?
    - Как реализуется наследование в Golang?


==============================
    Сборщик мусора
==============================

Редко
-------------
    - Как приходилось работать со сборкой мусора?
    - Как работает GC, его алгоритм и когда запускается?
    - Вот выделилась память и она используется, зачем в таком случае нужен GC?
    - Для чего используется GC?
    - Какие есть рекомандации как упростить жизнь GC?
    - Можно ли как-то отключить GC или ограничить запуски?
    - Что такое GC?
    - Что такое сборка мусора?


==============================
    Строки
==============================

Средне
-------------
    - Что такое string?

Редко
-------------
    - Приходит строка в utf8, там могут быть русские символы. Как узнать есть ли там русские буквы икак узнать длину в символах?
    - Какие особенности есть у string?
    - Как работать с utf8 строкой?


==============================
    Структуры
==============================

Редко
-------------
    - Имеет ли значение порядок полей в структуре?
    - От чего зависит размер выравнивания в структуре?
    - Что такое структура?


==============================
    Пакеты
==============================

Редко
-------------
    - Что такое пакет?
    - Расскажи про папку internal
