

==============================
    Мапа
==============================
Часто
-------------
    - Что такое мапа?
    Это встроенный тип данных, который представляет собой коллекцию пар "ключ-значение"

Средне
-------------
    - Что произойдет при конкуррентной записи в мапу?
    При конкуррентной (параллельной) записи в мапу из нескольких горутин может возникнуть состояние гонки,
    что приведет к неопределенному поведению программы. Это может вызвать панику. Чтобы избежать проблем с конкуррентным
    доступом к мапе, можно использовать sync.Mutex или sync.Map
    - Как устроена мапа под капотом?
    Основные компоненты мапы в Go
    Хэш-функция:
    Каждый ключ в мапе преобразуется в хэш (целое число) с помощью хэш-функции.
    Хэш-функция должна быть быстрой и равномерно распределять ключи по хэш-таблице, чтобы минимизировать коллизии.
    Бакеты (buckets):
    Мапа в Go состоит из массива бакетов. Каждый бакет содержит несколько пар "ключ-значение".
    Количество бакетов всегда является степенью двойки (например, 8, 16, 32 и т.д.), что позволяет использовать побитовые
    операции для быстрого вычисления индекса бакета.
    Хэш-таблица:
    Хэш-таблица — это массив бакетов. Каждый бакет содержит:
    Массив ключей.
    Массив значений.
    Указатель на следующий бакет (для разрешения коллизий методом цепочек).
    Коллизии:
    Коллизия возникает, когда два разных ключа имеют одинаковый хэш и попадают в один и тот же бакет.
    В Go коллизии разрешаются с помощью метода цепочек (chaining): если бакет переполняется, создается новый бакет, который связывается с текущим.
    Как работает мапа
    Добавление элемента:
    Вычисляется хэш ключа.
    По хэшу определяется индекс бакета в хэш-таблице.
    Если бакет уже содержит элементы, происходит проверка на коллизии. Если ключ уже существует, значение обновляется.
    Если ключ новый, он добавляется в бакет.
    Получение элемента:
    Вычисляется хэш ключа.
    По хэшу определяется индекс бакета.
    В бакете ищется ключ. Если ключ найден, возвращается соответствующее значение. Если ключ не найден, возвращается нулевое значение для типа значения.
    Удаление элемента:
    Вычисляется хэш ключа.
    По хэшу определяется индекс бакета.
    В бакете ищется ключ. Если ключ найден, он удаляется из бакета.
    Динамическое расширение мапы
    Когда мапа становится слишком заполненной (например, количество элементов превышает определенный порог), Go автоматически
    увеличивает размер хэш-таблицы. Это называется рехэшированием (rehashing):
    Создается новая хэш-таблица с большим количеством бакетов.
    Все существующие элементы пересчитываются и перемещаются в новую хэш-таблицу.
    Старая хэш-таблица удаляется.
    - Какие ключи могут быть у мапы?
    В Go ключи мапы (map) могут быть любого типа, для которого определена операция сравнения на равенство (==).
    Типы, которые могут быть ключами мапы: базовые типы (int, int8, int16, int32, int64, uint, uint8, uint16, uint32, uint64,
    float32, float64, complex64, complex128, string, bool), указатели на сравниваемые типы, каналы, интерфейсы (если их
    динамические значения сравнимы), структуры (если все их поля сравнимы), массивы (если их элементы сравнимы).
    - Какая сложность работы с мапой?
    Сложность (временная и пространственная) работы с мапой в Go зависит от операций, которые вы выполняете.
    Вставка (добавление или обновление элемента):
    В среднем: O(1).
    В худшем случае: O(n), где n — количество элементов в мапе. Это происходит при большом количестве коллизий,
    когда все элементы попадают в один бакет, и мапе приходится выполнять рехэширование.
    Поиск (получение элемента по ключу):
    В среднем: O(1).
    В худшем случае: O(n), если все элементы попадают в один бакет (крайне редкая ситуация при хорошей хэш-функции).
    Удаление элемента:
    В среднем: O(1).
    В худшем случае: O(n), если все элементы попадают в один бакет.
    Итерация по мапе:
    Временная сложность: O(n), где n — количество элементов в мапе.
    Пространственная сложность: O(1), так как итерация не требует дополнительной памяти.
    - Можно ли взять адрес элемента мапы и почему?
    В Go нельзя взять адрес элемента мапы, так как мапа — это динамическая структура данных, и её элементы могут быть перемещены
    в памяти при изменении мапы. Это ограничение помогает избежать ошибок, связанных с изменением мапы, и делает поведение программы более предсказуемым.
    Если нужно изменять значения в мапе, можно использовать указатели или копирование значений.
    - Как работает эвакуация данных?
    Эвакуация данных (evacuation) в мапе Go — это процесс перераспределения элементов мапы при её расширении (рехэшировании).
    Как работает эвакуация данных?
    Инициализация новой хэш-таблицы:
    Создается новая хэш-таблица с большим количеством бакетов (обычно в 2 раза больше, чем в старой таблице).
    Постепенная эвакуация:
    Эвакуация выполняется постепенно, чтобы не блокировать работу с мапой на долгое время.
    Go использует фоновую эвакуацию: элементы перемещаются из старой хэш-таблицы в новую по мере обращения к мапе.
    Пересчет индексов бакетов:
    Для каждого элемента вычисляется новый индекс бакета в новой хэш-таблице. Это делается с помощью той же хэш-функции, но с учетом нового количества бакетов.
    Перемещение элементов:
    Элементы из старой хэш-таблицы перемещаются в новую. Если в новом бакете уже есть элементы, они связываются в цепочку (метод цепочек).
    Очистка старой хэш-таблицы:
    После завершения эвакуации старая хэш-таблица удаляется.

Редко
-------------
    - Как разрешаются коллизии в мапе?
    В Go используется метод цепочек (chaining). Вот как это работает:
    Каждый бакет содержит массив пар "ключ-значение":
    Каждый бакет может хранить несколько пар "ключ-значение". В Go каждый бакет может содержать до 8 пар.
    Если бакет переполняется, создается новый бакет:
    Если в бакете уже есть 8 пар, и добавляется новая пара, создается новый бакет, который связывается с текущим. Это называется цепочкой (chain).
    Поиск в цепочке:
    При поиске элемента сначала вычисляется хэш ключа, определяется бакет, а затем выполняется поиск по цепочке (если она есть).
    - Как сделать конкурентную запись в мапу?
    sync.Mutex или sync.RWMutex для простых случаев.
    sync.Map для высоконагруженных приложений.
    Каналы для сложных сценариев с централизованным управлением доступом.
    - Как достигается константная сложность работы с мапой?
    Константная сложность (O(1)) работы с мапой в Go достигается благодаря:
    Использованию хэш-таблицы.
    Хорошей хэш-функции, равномерно распределяющей ключи по бакетам.
    Методу цепочек для разрешения коллизий.
    Динамическому расширению мапы при увеличении количества элементов.
    - В функции make для мапы мы указываем число. Что оно дает?
    Это предполагаемое количество элементов, которые будут храниться в мапе. Это не жесткое ограничение, а лишь подсказка для Go,
    чтобы выделить достаточно памяти заранее.
    - Для чего используется мапа?
    Основные сценарии использования мапы
    Хранение данных по ключу:
    Мапа позволяет хранить данные в виде пар "ключ-значение". Это полезно, когда вам нужно быстро находить значение по уникальному ключу.
    Подсчет частоты элементов:
    Мапа часто используется для подсчета частоты элементов в коллекции.
    Кэширование данных:
    Мапа может использоваться для кэширования результатов вычислений или запросов к базе данных, чтобы избежать повторных вычислений или запросов.
    Группировка данных:
    Мапа позволяет группировать данные по определенному признаку.
    Реализация множеств (sets):
    В Go нет встроенного типа "множество", но его можно эмулировать с помощью мапы, где ключи — это элементы множества,
    а значения — пустые структуры (или bool).
    Конфигурации и настройки:
    Мапа может использоваться для хранения конфигураций или настроек, где ключи — это названия параметров, а значения — их значения.
    Реализация словарей:
    Мапа может использоваться для реализации словарей, где ключи — это слова, а значения — их определения или переводы.
    - Мапа потокобезопасная?
    Нет, мапа (map) в Go не является потокобезопасной (not thread-safe). Это означает, что одновременный доступ к мапе из нескольких горутин
    без синхронизации может привести к состоянию гонки и неопределенному поведению программы, включая панику.
    - Пробовали из разных потоков писать в мапу?
    Да, например мапа использовалась в моем проекте в пакете базы данных для получения и хранения записей. Для решения многопоточности я использовала мьютекс.
    - Стало слишком много коллизий в мапе, как решить проблему?
    Увеличение количества бакетов
    Go автоматически увеличивает количество бакетов в мапе, когда она становится слишком заполненной. Однако можно помочь этому процессу,
    указав предполагаемую ёмкость мапы при её создании.
    Использование лучшей хэш-функции
    Хэш-функция в Go встроена и оптимизирована для большинства сценариев. Однако если вы используете пользовательские типы в качестве ключей,
    убедитесь, что ваша хэш-функция равномерно распределяет ключи по бакетам.
    Уменьшение нагрузки на мапу
    Если мапа становится слишком "плотной" (много коллизий), можно уменьшить нагрузку, удалив ненужные элементы или разделив данные на несколько мап.
    Использование sync.Map
    Если вы работаете с высоконагруженной мапой в многопоточной среде, рассмотрите использование sync.Map. Он оптимизирован для случаев, когда ключи
    часто читаются, но редко записываются.
    Переход на другую структуру данных
    Если мапа не подходит для вашего сценария (например, из-за частых коллизий), рассмотрите использование других структур данных, таких как:
    Слайс (slice): Если ключи — это целые числа.
    Дерево (tree): Если требуется упорядоченность.
    База данных: Если данных слишком много для хранения в памяти.
    - Какая сложность работы с мапой в худшем случае?
    В худшем случае сложность работы с мапой (map) в Go может достигать O(n), где n — количество элементов в мапе.
    Почему в худшем случае O(n)?
    Мапа в Go реализована как хэш-таблица, и её производительность зависит от равномерного распределения ключей по бакетам.
    В идеальном случае (мало коллизий) сложность операций (вставка, поиск, удаление) составляет O(1). Однако в худшем случае:
    Все ключи попадают в один бакет:
    Если хэш-функция возвращает одинаковый хэш для всех ключей, все элементы будут храниться в одном бакете.
    В этом случае мапа вырождается в связный список, и операции требуют обхода всех элементов.
    Длина цепочки становится O(n):
    Если в одном бакете хранится n элементов, то для поиска, вставки или удаления элемента потребуется обойти все n элементов.
    - Что произойдет при конкуррентном чтении из мапы?
    В Go мапа (map) не является потокобезопасной (not thread-safe). Это означает, что конкуррентное (параллельное) чтение из мапы
    без синхронизации может привести к неопределенному поведению, если одновременно с чтением происходит запись. Однако,
    если только чтение выполняется из нескольких горутин, это безопасно.
    - Чем мапа отличается от sync.Map?
    *Потокобезопасность
    Мапа (map):
    Не является потокобезопасной.
    Если несколько горутин одновременно читают и пишут в мапу, это может привести к состоянию гонки (race condition) и панике.
    Для безопасного использования в многопоточной среде требуется синхронизация (например, с помощью sync.Mutex или sync.RWMutex).
    sync.Map:
    Потокобезопасна.
    Предоставляет встроенные методы для безопасного использования в многопоточной среде.
    Не требует дополнительной синхронизации.
    *Производительность
    Мапа (map):
    Оптимизирована для однопоточного использования.
    В среднем операции (вставка, поиск, удаление) выполняются за O(1).
    В многопоточной среде требует использования мьютексов, что может снизить производительность.
    sync.Map:
    Оптимизирована для многопоточных сценариев, где ключи часто читаются, но редко записываются.
    Вставка, поиск и удаление могут быть медленнее, чем у обычной мапы, из-за накладных расходов на синхронизацию.
    Подходит для сценариев с высокой конкуренцией за чтение.
    *API
    Мапа (map):
    Использует стандартный синтаксис для работы с ключами и значениями
    sync.Map:
    Использует методы для работы с ключами и значениями
    *Типы ключей и значений
    Мапа (map):
    Ключи и значения могут быть любого типа, для которого определена операция сравнения на равенство (==).
    sync.Map:
    Ключи и значения имеют тип interface{}, что позволяет использовать любые типы.
    *Итерация
    Мапа (map):
    Итерация выполняется с помощью цикла for range
    Порядок итерации не гарантируется.
    sync.Map:
    Итерация выполняется с помощью метода Range
    *Использование памяти
    Мапа (map):
    Использует меньше памяти, чем sync.Map, так как не имеет накладных расходов на синхронизацию.
    sync.Map:
    Использует больше памяти из-за внутренних структур для обеспечения потокобезопасности.
    **Когда использовать мапу, а когда sync.Map?
    Используйте мапу (map), если:
    Вы работаете в однопоточном режиме.
    Вам нужна максимальная производительность.
    Вы готовы самостоятельно управлять синхронизацией (например, с помощью sync.Mutex).
    Используйте sync.Map, если:
    Вы работаете в многопоточной среде.
    Ключи часто читаются, но редко записываются.
    Вам нужна встроенная потокобезопасность без необходимости использовать мьютексы.


==============================
    Массивы/Слайсы
==============================
Часто
-------------
    - Что такое слайс?
    Слайс (slice) — это динамическая структура данных, которая представляет собой последовательность элементов одного типа.
    Слайс является более гибкой и мощной версией массива, так как он может изменять свой размер во время выполнения программы.
    - Чем массив отличается от слайса?
    *Размер
    Массив:
    Имеет фиксированный размер, который задается при объявлении и не может быть изменен во время выполнения программы.
    Слайс:
    Имеет динамический размер, который может изменяться во время выполнения программы.
    *Передача в функции
    Массив:
    Передается по значению. Это означает, что при передаче массива в функцию создается его копия, и изменения внутри функции
    не влияют на оригинальный массив.
    Слайс:
    Передается по ссылке. Слайс содержит указатель на массив, поэтому изменения внутри функции влияют на оригинальный слайс.
    *Инициализация
    Массив:
    Размер должен быть указан явно при объявлении.
    Слайс:
    Размер не указывается явно. Слайс может быть создан пустым или с начальными значениями.
    *Емкость (capacity)
    Массив:
    Емкость массива всегда равна его размеру и не может быть изменена.
    Слайс:
    Емкость слайса может быть больше его длины, что позволяет добавлять элементы без выделения новой памяти.
    * Изменение размера
    Массив:
    Размер массива нельзя изменить после его создания.
    Слайс:
    Размер слайса можно изменить с помощью функции append.
    *Тип
    Массив:
    Тип массива включает его размер. Например, [3]int и [5]int — это разные типы.
    Слайс:
    Тип слайса не включает его размер. Все слайсы одного типа элементов ([]int, []string) считаются одинаковыми.
    * Использование в реальных задачах
    Массив:
    Используется реже, так как его фиксированный размер ограничивает гибкость.
    Подходит для случаев, когда размер данных известен заранее и не изменяется.
    Слайс:
    Используется чаще, так как он более гибкий и удобный для работы с динамическими данными.
    Подходит для большинства задач, где требуется работать с последовательностями данных.

Средне
-------------
    - Как работает append?
    append добавляет элементы в слайс. Если в слайсе достаточно места (емкость позволяет), элементы добавляются в существующий массив.
    Если места нет, Go выделяет новый массив с увеличенной емкостью (обычно в 2 раза больше), копирует туда старые элементы, добавляет
    новые и возвращает новый слайс. Всегда нужно присваивать результат append обратно в переменную, так как слайс может измениться.
    Амортизированная сложность — O(1), благодаря экспоненциальному росту емкости.

Редко
-------------
    - Как правильно/неправильно работать со слайсом?
    - Для чего можно использовать массивы в Golang?
    Массивы в Go используются, когда размер данных фиксирован и известен заранее. Например:
    Для хранения статических структур (координаты, матрицы).
    Когда нужна предсказуемость и эффективность по памяти.
    Для ключей в map, так как массивы поддерживают сравнение по значению.
    В низкоуровневых операциях (работа с бинарными данными, заголовками).
    - До какого размера можно увеличивать слайс?
    Теоретически слайс можно увеличивать до максимального значения int, ограниченного архитектурой системы.
    На практике размер слайса ограничен доступной памятью и производительностью.
    При работе с очень большими слайсами важно учитывать затраты на память и время копирования данных.
    - Допустима ли конкуррентная работа со слайсом?
    Конкурентная работа со слайсом без синхронизации недопустима.
    Для безопасной работы можно использовать:
    sync.Mutex для блокировки доступа.
    Каналы для передачи данных между горутинами.
    sync.WaitGroup для ожидания завершения горутин.
    Если требуется частое изменение слайса, можно использовать специализированные потокобезопасные структуры, например,
    из пакета sync/atomic или сторонних библиотек.
    (Так же всегда проверять код на наличие гонок с помощью go run -race)
    - Для чего используются слайсы?
   Слайсы используются для работы с коллекциями данных, когда размер может изменяться. Они гибче массивов, так как могут расти
     или уменьшаться с помощью append.
     Основные сценарии использования:
     Динамические данные: Когда количество элементов заранее неизвестно.
     Работа с подмножествами: Срезы позволяют брать часть слайса без копирования.
     Эффективность: Слайсы передаются по ссылке, что экономит память.
     Структуры данных: Слайсы легко адаптируются для стеков, очередей.
     Работа с файлами/сетью: Чтение и запись данных.
     Сортировка и поиск: Интеграция с пакетом sort.
     JSON и сериализация: Удобно для работы с форматами данных.
    - Берем от слайса слайс, куда будет указывать его указатель?
    Когда мы берем слайс от слайса, новый слайс указывает на тот же массив, что и исходный, но только на его часть.
    Это позволяет эффективно работать с подмножествами данных, но требует осторожности, так как изменения в одном слайсе могут повлиять на другой.
    - В чем разница между слайсом указателей и слайсом значений с точки зрения вызова функции?
    Слайс значений
    Передается копия заголовка, но данные изменяются в оригинальном массиве.
    Слайс указателей
    Передается копия заголовка, но изменяются данные по указателям.
    Выбор зависит от задачи: если нужно изменять данные — слайс значений; если нужно избежать копирования или работать с nil — слайс указателей.
    - Где в памяти размещается массив, а где слайс?
Массив:
Хранится в стеке (если локальный и небольшой) или в куче (если динамический или часть структуры).
Фиксированный размер.
Слайс:
Заголовок слайса (указатель, длина, емкость) хранится в стеке.
Данные слайса (массив) всегда хранятся в куче.
    - Какие методы оптимизации работы со слайсами ты бы применил в работе?
    Для оптимизации работы со слайсами в Go я бы использовала следующие подходы:
    Предварительное выделение памяти через make с указанием емкости, чтобы избежать частых переаллокаций при использовании append.
    Минимизация копирования данных: вместо присваивания слайсов использовал бы copy, чтобы создавать независимые копии.
    Использование срезов для работы с подмножествами данных без копирования.
    Избежание частых вызовов append в циклах: заранее выделял бы память, чтобы уменьшить количество переаллокаций.
    Передача больших слайсов по указателю в функции, чтобы избежать копирования заголовка слайса.
    Использование sync.Pool для слайсов, которые часто создаются и удаляются, чтобы снизить нагрузку на сборщик мусора.
    Очистка слайсов перед повторным использованием, чтобы избежать лишних аллокаций.
    Проверка емкости перед добавлением элементов, чтобы избежать неожиданных переаллокаций.
    Эти методы помогают улучшить производительность и эффективность работы со слайсами, особенно при работе с большими объемами данных.
    (Аллокация — это выделение памяти для данных (например, для слайса или массива).
     Переаллокация — это процесс выделения нового блока памяти большего размера и копирования туда данных, когда текущей памяти
     недостаточно)
    - Какие есть ограничения при работе со слайсом?
    Изменение исходного массива: Слайсы ссылаются на базовый массив, поэтому изменение одного слайса может повлиять на другие,
    если они используют тот же массив.
    Утечки памяти: Если слайс ссылается на большой массив, даже маленький срез может удерживать весь массив в памяти.
     Чтобы избежать этого, можно использовать copy для создания независимого слайса.
    Переаллокации при append: Если емкость слайса недостаточна, append выделяет новый массив и копирует данные. Это можно
    минимизировать, предварительно выделяя память через make с указанием емкости.
    Ошибки индексации: Доступ к элементам за пределами длины слайса вызывает панику. Всегда нужно проверять длину перед доступом.
    Сравнение слайсов: Слайсы нельзя сравнивать напрямую через ==. Для сравнения можно использовать reflect.DeepEqual.
    Конкурентный доступ: Слайсы не потокобезопасны. Для работы с ними в многопоточной среде нужно использовать мьютексы или каналы.
    Передача в функции: Слайсы передаются по значению (копируется заголовок), но данные остаются общими. Если нужно избежать изменений, можно передавать слайс по указателю или создавать копию.
    - Какие есть средства для добавления элементов в слайс?
    Основное средство для добавления элементов в слайс в Go — это функция append. Она позволяет добавлять один или несколько
    элементов в конец слайса и автоматически увеличивает его емкость, если это необходимо.
    Если нужно добавить элементы из другого слайса, можно использовать append с оператором ...
    Для оптимизации можно заранее выделить память с помощью make, чтобы избежать переаллокаций
    В высокопроизводительных сценариях можно использовать sync.Pool для повторного использования слайсов и уменьшения нагрузки на сборщик мусора.
    - Какая есть функции для создания слайса с длиной отличной от нуля?
    make([]T, length) — создает слайс с заданной длиной.
    Инициализация с элементами — []T{...}.
    Создание из массива — arr[:].
    Использование append — добавление элементов в пустой слайс.
    Копирование данных — copy.
    - С какой скоростью идет поиск в массиве и почему?
    Линейный поиск в массиве имеет сложность O(n), так как нужно проверить каждый элемент.
    Если массив отсортирован, можно использовать бинарный поиск со сложностью O(log n).
    Бинарный поиск:
    Делит массив на две части.
    Сравнивает искомый элемент с элементом в середине массива.
    Если элемент не найден, поиск продолжается в одной из половин.
    - Чем хорош массив по сравнению со слайсом?
    Фиксированный размер: Массивы имеют фиксированный размер, который задается на этапе компиляции. Это делает их предсказуемыми
    и безопасными, когда размер данных известен заранее.
    Эффективность по памяти: Массивы хранят данные непосредственно в своей структуре, без накладных расходов на заголовок,
    как у слайсов. Это делает их более эффективными для небольших и статических данных.
    Быстрый доступ к элементам: Доступ к элементам массива происходит за O(1), так как массив — это непрерывный блок памяти.
    Это полезно для задач, где важна скорость доступа.
    Безопасность: Массивы не могут быть изменены по размеру, что исключает риск переаллокаций или утечек памяти. Это делает
    их более безопасными в многопоточных приложениях.
    Передача по значению: Массивы передаются в функции по значению, то есть создается копия. Это полезно, если нужно гарантировать,
     что исходные данные не изменятся.
    Использование как ключи в мапах: Массивы можно использовать как ключи в мапах, так как они поддерживают сравнение по значению.
    Слайсы, напротив, нельзя использовать как ключи.
    - Что такое массив?
    Массив в Go — это структура данных, которая представляет собой фиксированную последовательность элементов одного типа. Массив имеет
    строго определенный размер, который задается на этапе компиляции и не может быть изменен во время выполнения программы.


==============================
    Каналы
==============================
Часто
-------------
    - Что такое каналы?
    Каналы в Go — это механизм для безопасной передачи данных между горутинами. Они позволяют синхронизировать выполнение
     горутин и избежать гонок данных. Каналы бывают буферизованными (с фиксированной ёмкостью) и небуферизованными (синхронными).
     Создаются через make, данные отправляются с помощью <-, а закрываются через close. Каналы часто используются вместе с
     select для работы с несколькими каналами одновременно.

Средне
-------------
    - Как устроен канал и как он работает под капотом?
Канал в Go — это структура hchan, которая управляет передачей данных между горутинами. Вот как это работает под капотом:
Структура канала:
Буфер: Если канал буферизованный, данные хранятся в кольцевом буфере (кольцевой очереди).
Очереди горутин: Есть две очереди — sendq (горутины, ожидающие отправки) и recvq (горутины, ожидающие получения).
Мьютекс: Защищает доступ к внутренним данным канала.
Тип данных: Канал знает, данные какого типа он передаёт.
Отправка и получение:
Небуферизованный канал: Работает синхронно. Отправка (ch <- data) блокирует горутину, пока не появится получатель, и наоборот.
Буферизованный канал: Данные сначала помещаются в буфер. Отправка блокируется только при заполнении буфера, а получение — при его опустошении.
Синхронизация:
Если операция (отправка или получение) не может быть выполнена сразу, горутина блокируется и добавляется в соответствующую очередь (sendq или recvq).
Когда появляется возможность (например, приходит получатель для отправки или отправитель для получения), горутина пробуждается.
Закрытие канала:
При закрытии (close(ch)) все горутины в recvq пробуждаются и получают нулевое значение.
Попытка отправить в закрытый канал вызывает панику.
Производительность:
Каналы оптимизированы для работы с горутинами и используют низкоуровневые примитивы синхронизации (атомарные операции, футексы).
Буферизованные каналы копируют данные в буфер, что может быть менее эффективно, чем прямой обмен.
    - Какие есть типы каналов в Golang?
    1. Небуферизованные каналы:
    Создаются с помощью make(chan T), где T — тип данных.
    Работают синхронно: отправка (ch <- data) блокирует горутину, пока другая горутина не начнёт получать данные, и наоборот.
    2. Буферизованные каналы:
    Создаются с помощью make(chan T, capacity), где capacity — размер буфера.
    Отправка блокируется только при заполнении буфера, а получение — при его опустошении.
    Также каналы могут быть однонаправленными (только для отправки или получения) и закрываемыми.
    Направление каналов:
    Каналы могут быть однонаправленными: только для отправки (chan<- T) или только для получения (<-chan T).
    Закрытие каналов:
    Каналы можно закрывать с помощью close(ch). Это полезно для сигнализации о завершении работы.
    - Что если писать/читать в закрытый канал?
    Попытка отправить в закрытый канал вызывает панику, а получение возвращает нулевое значение и false.

Редко
-------------
    - Что будет при записи в закрытый канал?
    Запись в закрытый канал вызывает панику.
    Чтобы избежать паники, нужно гарантировать, что канал закрывается только после завершения всех операций записи.
    - Чем отличается запись/чтение в буферизованном и небуферизованном канале?
    Основное отличие между буферизованными и небуферизованными каналами в Go заключается в поведении при записи (отправке) и чтении (получении) данных.
    Вот ключевые различия:
    1. Небуферизованный канал:
    Создаётся с помощью make(chan T).
    Синхронный обмен: Отправка и получение данных происходят одновременно.
    Блокировка:
    Запись (ch <- data): Блокирует горутину, пока другая горутина не начнёт читать из канала.
    Чтение (<-ch): Блокирует горутину, пока другая горутина не начнёт писать в канал.
     Буферизованный канал:
    Создаётся с помощью make(chan T, capacity), где capacity — размер буфера.
    Асинхронный обмен: Данные могут быть записаны в буфер без ожидания получателя, пока буфер не заполнится.
    Блокировка:
    Запись (ch <- data): Блокирует горутину, только если буфер заполнен.
    Чтение (<-ch): Блокирует горутину, только если буфер пуст.
    - Что произойдет с читателями/писателями если закрыть канал?
    1. Читатели (получатели):
    Если канал закрыт, чтение из канала (<-ch) продолжает работать, но возвращает нулевое значение для типа канала и false в
    качестве второго значения (флаг ok).
    Это позволяет читателям определить, что канал закрыт, и корректно завершить свою работу.
    Если читатель использует range для чтения из канала, цикл автоматически завершится, когда канал будет закрыт.
    2. Писатели (отправители):
    Попытка записать в закрытый канал (ch <- data) вызывает панику (panic).
    Это защитный механизм, который предотвращает некорректное использование канала.
    3. Закрытие канала и горутины:
    Когда канал закрывается, все заблокированные читатели (горутины, ожидающие данных из канала) пробуждаются и
    получают нулевое значение и false.
    Заблокированные писатели (горутины, пытающиеся записать в канал) не пробуждаются — вместо этого они вызовут панику,
     если попытаются записать в закрытый канал.
    - Что если закрыть закрытый канал?
    Закрытие закрытого канала вызывает панику.
    Чтобы избежать этого, нужно гарантировать, что канал закрывается только один раз.
    - Что используется для неблокирующего чтения из канала?
    Для неблокирующего чтения из канала используется select с веткой default.
    Если данные в канале есть, выполняется ветка case.
    Если данных нет, выполняется ветка default, и программа продолжает работу без блокировки.
    Этот подход полезен, когда нужно проверять состояние канала без остановки выполнения программы.
    - Какие операции есть с каналами?
    1. Создание канала:
    Канал создаётся с помощью функции make.
    Пример:
    ch := make(chan int)       // Небуферизованный канал
    chBuffered := make(chan int, 10) // Буферизованный канал с ёмкостью 10
    2. Отправка данных в канал:
    Используется оператор <-.
    Пример:
    ch <- 42 // Отправка значения 42 в канал
    3. Получение данных из канала:
    Используется оператор <-.
    Пример:
    value := <-ch // Получение значения из канала
    4. Закрытие канала:
    Закрытие канала выполняется с помощью функции close.
    После закрытия канала в него нельзя отправлять данные, но можно читать оставшиеся данные.
    Пример:
    close(ch)
    5. Проверка на закрытие канала:
    При чтении из канала можно использовать второй аргумент (флаг ok), чтобы проверить, закрыт ли канал.
    Пример:
    value, ok := <-ch
    if !ok {
        fmt.Println("Канал закрыт")
    }
    6. Использование select для работы с несколькими каналами:
    select позволяет ждать выполнения одной из нескольких операций с каналами.
    Пример:
    select {
    case msg1 := <-ch1:
        fmt.Println("Получено из ch1:", msg1)
    case msg2 := <-ch2:
        fmt.Println("Получено из ch2:", msg2)
    default:
        fmt.Println("Нет данных в каналах")
    }
    7. Неблокирующие операции:
    Используя select с веткой default, можно выполнять неблокирующие операции с каналами.
    Пример:
    select {
    case value := <-ch:
        fmt.Println("Получено:", value)
    default:
        fmt.Println("Данных нет")
    }
    8. Итерация по каналу с помощью range:
    Канал можно использовать в цикле for range, чтобы читать данные до тех пор, пока канал не будет закрыт.
    Пример:
    for value := range ch {
        fmt.Println("Получено:", value)
    }
    9. Однонаправленные каналы:
    Каналы могут быть ограничены только для отправки (chan<- T) или только для получения (<-chan T).
    Пример:
    func sendData(ch chan<- int) {
        ch <- 42
    }
    func receiveData(ch <-chan int) int {
        return <-ch
    }
    10. Закрытие канала и пробуждение горутин:
    При закрытии канала все горутины, ожидающие чтения из него, пробуждаются и получают нулевое значение.
    Пример:
    ch := make(chan int)
    go func() {
        value, ok := <-ch
        if !ok {
            fmt.Println("Канал закрыт")
        }
    }()
    close(ch)
    - Какие параметры могут иметь каналы?
    Основные параметры каналов:
    Тип данных — тип значений, передаваемых через канал.
    Ёмкость (буфер) — размер буфера для буферизованных каналов.
    Направление — однонаправленность (только отправка или только получение).
    Состояние — открыт или закрыт.
    Блокировка — поведение при отправке и получении данных.
    Размер буфера — текущее количество элементов и ёмкость буфера.
    - Для чего используется select при работе с каналами?
    Ожидать операций на нескольких каналах (чтение/запись).
    Реализовывать таймауты с помощью time.After.
    Выполнять неблокирующие операции через default.
    Останавливать горутины через канал done.
    Мультиплексировать каналы, обрабатывая данные из нескольких каналов в одной горутине.
    - Как проверить, что канал закрыт?
    Чтобы проверить, что канал закрыт, используется второй аргумент при чтении из канала. Этот аргумент (ok) имеет тип bool и возвращает:
    true, если канал открыт и данные успешно прочитаны.
    false, если канал закрыт и данных больше нет.
    - Как сделать канал буферизованным?
    Чтобы сделать канал буферизованным, укажите ёмкость буфера при создании: make(chan T, capacity).
    Буферизованные каналы позволяют записывать данные без блокировки, пока буфер не заполнится.
    - Есть две горутины, одна пишет в небуферизованный, а другая в буферизованный канал, оба не читаются. Что произойдет?
    1. Горутина, пишущая в небуферизованный канал:
    Небуферизованный канал работает синхронно: отправка (ch <- data) блокирует горутину, пока другая горутина не начнёт читать из канала.
    Если данные не читаются, горутина заблокируется навсегда (deadlock).
    2. Горутина, пишущая в буферизованный канал:
    Буферизованный канал позволяет записывать данные без блокировки, пока буфер не заполнится.
    Если ёмкость буфера достаточна для всех записываемых данных, горутина не блокируется.
    Если буфер заполнится, горутина заблокируется, пока данные не будут прочитаны.


==============================
    Примитивы синхронизации
==============================
Часто
-------------
    - Какие примитивы синхронизации есть в Golang?
    В Go (Golang) для синхронизации горутин и управления доступом к общим ресурсам используются следующие примитивы синхронизации:
    Каналы (Channels):
    Каналы являются основным средством коммуникации между горутинами. Они позволяют передавать данные между горутинами и синхронизировать их выполнение.
    Мьютексы (Mutexes):
    Мьютексы используются для обеспечения эксклюзивного доступа к общим ресурсам. В Go есть два типа мьютексов: sync.Mutex и sync.RWMutex.
    sync.Mutex предоставляет эксклюзивную блокировку: только одна горутина может захватить мьютекс.
    sync.RWMutex позволяет нескольким горутинам читать данные одновременно, но только одна горутина может писать.
    Группы ожидания (WaitGroups):
    sync.WaitGroup используется для ожидания завершения группы горутин. Это полезно, когда нужно дождаться завершения всех горутин
    перед продолжением выполнения программы.
    Однократное выполнение (Once):
    sync.Once гарантирует, что определенный код будет выполнен только один раз, даже если он вызывается из нескольких горутин.
    Пример:
    var once sync.Once
    once.Do(func() {
        // Этот код выполнится только один раз
    })
    Атомарные операции (Atomic):
    Пакет sync/atomic предоставляет низкоуровневые атомарные операции для работы с примитивными типами данных
     (например, int32, int64, uint32, uint64 и указатели). Эти операции позволяют выполнять операции чтения и записи без использования мьютексов.
    Пример:
    var counter int32
    atomic.AddInt32(&counter, 1)

Средне
-------------
    - Чем мьютекс отличается от семафора?
    Мьютекс (от mutual exclusion) — это примитив синхронизации, который обеспечивает эксклюзивный доступ к общему ресурсу.
     Только один поток (или горутина) может владеть мьютексом в любой момент времени.
    Основные характеристики:
    Владелец: Мьютекс имеет понятие "владельца". Только поток, который захватил мьютекс, может его освободить.
    Бинарность: Мьютекс может находиться в одном из двух состояний: захвачен (locked) или свободен (unlocked).
    Использование: Мьютекс используется для защиты критических секций кода, чтобы только один поток мог выполнять этот код одновременно.
    Семафор (Semaphore)
    Семафор — это более общий механизм синхронизации, который позволяет управлять доступом к ресурсу для нескольких потоков одновременно.
    Семафор поддерживает счетчик, который определяет, сколько потоков могут одновременно получить доступ к ресурсу.
    Основные характеристики:
    Счетчик: Семафор имеет счетчик, который указывает, сколько потоков могут одновременно получить доступ к ресурсу.
    Несколько потоков: В отличие от мьютекса, семафор может разрешать доступ нескольким потокам одновременно.
    Использование: Семафоры часто используются для управления доступом к ресурсам с ограниченной емкостью (например, пул соединений с базой данных).
    Пример использования семафора в Go:
    В стандартной библиотеке Go нет семафора, но его можно реализовать с помощью каналов:
    package main
    import (
    	"fmt"
    	"sync"
    	"time"
    )
    type Semaphore struct {
    	sem chan struct{}
    }
    func NewSemaphore(n int) *Semaphore {
    	return &Semaphore{
    		sem: make(chan struct{}, n),
    	}
    }
    func (s *Semaphore) Acquire() {
    	s.sem <- struct{}{}
    }
    func (s *Semaphore) Release() {
    	<-s.sem
    }
    func main() {
    	sem := NewSemaphore(2) // Разрешаем доступ 2 потокам одновременно
    	var wg sync.WaitGroup
    	for i := 0; i < 5; i++ {
    		wg.Add(1)
    		go func(id int) {
    			defer wg.Done()
    			sem.Acquire() // Захватываем семафор
    			defer sem.Release() // Освобождаем семафор
    			fmt.Printf("Goroutine %d started\n", id)
    			time.Sleep(time.Second) // Имитация работы
    			fmt.Printf("Goroutine %d finished\n", id)
    		}(i)
    	}
    	wg.Wait()
    }
    Вывод:
    Goroutine 0 started
    Goroutine 1 started
    Goroutine 0 finished
    Goroutine 2 started
    Goroutine 1 finished
    Goroutine 3 started
    Goroutine 2 finished
    Goroutine 4 started
    Goroutine 3 finished
    Goroutine 4 finished

Редко
-------------
    - Чем мьютексы отличаются от атомиков?
    Мьютексы:
    Что это?
    Мьютекс — это примитив синхронизации, который обеспечивает эксклюзивный доступ к ресурсу. Только один поток (или горутина)
    может захватить мьютекс и работать с защищаемым ресурсом.
    Как работает?
    Поток захватывает мьютекс (Lock), работает с ресурсом, а затем освобождает мьютекс (Unlock). Другие потоки ждут, пока мьютекс не будет освобожден.
    Когда использовать?
    Когда нужно защитить сложные операции или структуры данных (например, изменение нескольких переменных или доступ к сложным объектам).
    Пример в Go:
    var mu sync.Mutex
    var counter int
    func increment() {
        mu.Lock()
        counter++
        mu.Unlock()
    }
    Атомики:
    Что это?
    Атомики — это низкоуровневые операции, которые гарантируют, что определенные действия (например, чтение, запись или изменение)
    будут выполнены атомарно (без вмешательства других потоков).
    Как работает?
    Атомики работают на уровне процессора и не требуют блокировок. Они позволяют безопасно изменять примитивные типы данных
    (например, int32, int64, указатели).
    Когда использовать?
    Когда нужно выполнять простые операции (например, инкремент, декремент, сравнение и замену) над одной переменной.
    Атомики быстрее мьютексов, но подходят только для простых сценариев.
    Пример в Go:
    var counter int32
    func increment() {
        atomic.AddInt32(&counter, 1)
    }
    - Что из пакета sync используешь на практике?
    sync.Mutex и sync.RWMutex использую для защиты общих ресурсов от гонок данных. Например, когда несколько горутин работают с одной структурой данных,
    Mutex гарантирует, что только одна горутина сможет изменять данные в конкретный момент времени.  RWMutex полезен, когда есть много читателей и мало
    писателей. Он позволяет нескольким горутинам читать данные одновременно, но блокирует их при записи. sync.WaitGroup использую для ожидания завершения
     группы горутин. Например, когда нужно дождаться, пока все горутины закончат свою работу, прежде чем продолжить выполнение программы.
     sync.Once Использую, когда нужно гарантировать, что определенный код выполнится только один раз, даже если он вызывается из нескольких горутин.
     Например, для инициализации синглтона. Пример:
     var once sync.Once
     var config map[string]string
     func loadConfig() {
         once.Do(func() {
             config = map[string]string{"key": "value"}
         })
     }
     sync.Pool спользую для пулинга объектов, чтобы уменьшить нагрузку на сборщик мусора. Например, когда нужно часто создавать и удалять временные
     объекты. Пример:
     var pool = sync.Pool{
         New: func() interface{} {
             return make([]byte, 1024)
         },
     }
     buf := pool.Get().([]byte)
     defer pool.Put(buf)
     sync.Map использую в редких случаях, когда нужна конкурентная map, и нет возможности использовать Mutex или RWMutex. sync.Map оптимизирован
     для сценариев, где ключи часто читаются, но редко записываются.
    - Что можно использовать для ожидания выполнения N горутин?
    Для ожидания выполнения N горутин в Go чаще всего используется sync.WaitGroup. Это простой и эффективный способ дождаться завершения группы горутин.
   Add(n int): Увеличивает счетчик на n (количество горутин, которые нужно дождаться).
    Done(): Уменьшает счетчик на 1 (вызывается внутри горутины, когда она завершает свою работу).
  Wait(): Блокирует выполнение, пока счетчик не станет равным 0 (то есть пока все горутины не завершатся).
  Так же ожно использовать каналы для синхронизации, но это менее удобно для ожидания завершения N горутин.
  Или errgroup.Group (из пакета golang.org/x/sync/errgroup): Полезен, если нужно обрабатывать ошибки от горутин.
    - Какие примитивы синхронизации использовал в работе и для чего?
    ync.Mutex для работы с хранилищем базы данных, sync.Once для инициализация подключения к базе данных при первом обращении,
    загрузки конфигурации приложения (только один раз), sync.Pool для пула байтовых буферов для работы с сетью или файлами
    - Как устроена WaitGroup под капотом и как ее можно реализовать самому?
    sync.WaitGroup использует атомарные операции и блокировки для управления внутренним счетчиком. Вот основные компоненты:
    Счетчик (counter):
    Хранит количество активных задач (горутин), которые нужно дождаться.
    Увеличивается с помощью Add(n int) и уменьшается с помощью Done().
    Семафор (semaphore):
    Используется для блокировки горутины, вызывающей Wait(), пока счетчик не станет равным 0.
    Атомарные операции:
    Для изменения счетчика используются атомарные операции (например, atomic.AddInt32), чтобы избежать гонок данных.
    как реализовать?????
    - Сколько нужно ядер, чтобы начать использовать sync.Map?
    Количество ядер не является прямым критерием для использования sync.Map. Однако:
    Если у вас одно ядро, то sync.Map может быть избыточным, так как конкуренция между горутинами минимальна. В этом случае обычная map с
    sync.Mutex или sync.RWMutex будет работать достаточно эффективно. Если у вас много ядер (например, 4 и более), и вы ожидаете высокую конкуренцию
     за доступ к map, то sync.Map может показать себя лучше, чем обычная map с мьютексом, благодаря своей оптимизации для конкурентного доступа.
    - Расскажи про sync.Map
    sync.Map — это потокобезопасная реализация map в Go, оптимизированная для определенных сценариев использования.
    Основные особенности sync.Map:
    Потокобезопасность:
    sync.Map позволяет безопасно работать с map из нескольких горутин без необходимости использования дополнительных примитивов синхронизации,
    таких как sync.Mutex или sync.RWMutex.
    Оптимизация для специфичных сценариев:
    sync.Map оптимизирован для случаев, когда:
    Много читателей, мало писателей: Данные часто читаются, но редко обновляются.
    Динамические ключи: Ключи часто добавляются и удаляются.
    Методы:
    Store(key, value interface{}): Добавляет или обновляет значение по ключу.
    Load(key interface{}) (value interface{}, ok bool): Возвращает значение по ключу.
    Delete(key interface{}): Удаляет ключ и связанное с ним значение.
    LoadOrStore(key, value interface{}) (actual interface{}, loaded bool): Возвращает существующее значение или сохраняет новое, если ключ отсутствует.
    Range(f func(key, value interface{}) bool): Итерируется по map, применяя функцию f к каждой паре ключ-значение.
    Когда использовать sync.Map?
    Кэширование:
    Когда нужно кэшировать данные, которые редко изменяются, но часто читаются.
    Конфигурация:
    Для хранения конфигурации, которая может обновляться редко, но читаться часто.
    Динамические ключи:
    Когда ключи часто добавляются и удаляются, и требуется высокая производительность при конкурентном доступе.
    Преимущества sync.Map:
    Потокобезопасность:
    Не нужно использовать дополнительные примитивы синхронизации.
    Оптимизация:
    Высокая производительность в сценариях с большим количеством читателей и редкими записями.
    Простота использования:
    Удобный API для работы с конкурентными map.
    Недостатки sync.Map:
    Ограниченная гибкость:
    Нет прямого доступа к длине map.
    Нет поддержки операций, таких как len или cap.
    Не для всех сценариев:
    Если данные часто обновляются, sync.Map может быть менее эффективным, чем обычная map с sync.RWMutex.
    - Расскажи про пакет sync
    Пакет sync в Go предоставляет примитивы синхронизации для управления доступом к общим ресурсам в многопоточных приложениях. Он особенно полезен,
    когда нужно координировать работу горутин и избегать гонок данных (data races).
    Основные примитивы пакета sync:
    sync.Mutex и sync.RWMutex:
    Mutex (взаимное исключение) обеспечивает эксклюзивный доступ к ресурсу. Только одна горутина может захватить мьютекс и работать с ресурсом.
    RWMutex (read-write мьютекс) позволяет нескольким горутинам читать данные одновременно, но блокирует их при записи.
    sync.WaitGroup:
    Используется для ожидания завершения группы горутин. Основные методы:
    Add(n int): Увеличивает счетчик на n.
    Done(): Уменьшает счетчик на 1.
    Wait(): Блокирует выполнение, пока счетчик не станет равным 0.
    sync.Once:
    Гарантирует, что определенный код выполнится только один раз, даже если он вызывается из нескольких горутин.
    sync.Pool:
    Используется для пулинга объектов, чтобы уменьшить нагрузку на сборщик мусора. Объекты из пула можно временно использовать и возвращать обратно.
    sync.Map:
    Потокобезопасная реализация map, оптимизированная для сценариев с большим количеством читателей и редкими записями.
    sync.Cond:
    Условные переменные, которые позволяют горутинам ждать определенного события. Используется для сложных сценариев синхронизации.
    Когда использовать пакет sync?
    Когда нужно синхронизировать доступ к общим ресурсам в многопоточных приложениях.
    Для управления параллелизмом и избежания гонок данных.
    Для реализации сложных сценариев синхронизации, таких как пулы горутин, кэширование и однократная инициализация.
    Преимущества пакета sync:
    Простота:
    Примитивы sync просты в использовании и интегрированы в стандартную библиотеку.
    Эффективность:
    Оптимизированы для работы в многопоточных средах.
    Безопасность:
    Гарантируют корректную работу с общими ресурсами.
    Недостатки пакета sync:
    Низкоуровневость:
    Для некоторых задач (например, управления пулами горутин) могут потребоваться более высокоуровневые инструменты, такие как каналы или пакет context.
    Ограниченная гибкость:
    Например, sync.Map не поддерживает операции, такие как len или cap.
    - Когда нужно использовать Mutex, а когда RWMutex?
    Используйте Mutex, если:
    Данные часто изменяются.
    Нет необходимости в разделении доступа на чтение и запись.
    Используйте RWMutex, если:
    Данные часто читаются, но редко изменяются.
    Нужно повысить производительность за счет параллельного чтения.
    - Есть общий ресурс. Хотим, чтобы к нему одновременно обращались только N горутин. Как это сделать?
    Для ограничения количества горутин, которые одновременно могут обращаться к общему ресурсу, используйте семафор на основе буферизированного канала.
    - Запустим 1000 горутин с инкрементом инта. Получим в конце тысячу? Что делать, чтобы получить тысячу?
    Если нужно просто увеличить счетчик, sync/atomic — это самый быстрый и простой способ.
    Если нужно защитить более сложные операции, используйте sync.Mutex.
    Если нужно организовать более сложную синхронизацию, используйте каналы.
    - Есть глобальная мапа, глобальный мьютекс. Две функции. Одна блочит мьютекс, а вторая нет. Что произойдет?
    Если одна функция блокирует мьютекс перед доступом к мапе, а другая — нет, то вторая функция может читать или изменять мапу
    одновременно с первой. Это приведет к гонкам данных.
    - В чем разница между Mutex и RWMutex?
    Mutex обеспечивает эксклюзивный доступ к ресурсу. Только одна горутина может захватить мьютекс и работать с ресурсом. Остальные горутины
    блокируются до освобождения мьютекса.
    Методы:
    Lock(): Захватывает мьютекс. Если мьютекс уже захвачен, горутина блокируется.
    Unlock(): Освобождает мьютекс.
    Когда использовать?
    Когда нужно защитить ресурс, который часто изменяется (записи происходят чаще, чем чтения).
    Когда нет необходимости разделять доступ на чтение и запись.
    RWMutex позволяет нескольким горутинам читать данные одновременно, но блокирует их при записи. Это делает его более эффективным
    в сценариях, где чтение происходит чаще, чем запись.
    Методы:
    Lock() / Unlock(): Используются для эксклюзивного доступа на запись.
    RLock() / RUnlock(): Используются для неэксклюзивного доступа на чтение.
    Когда использовать?
    Когда данные часто читаются, но редко изменяются.
    Когда нужно повысить производительность за счет параллельного чтения.


==============================
    Горутины
==============================
Часто
-------------
    - Что такое горутина?
    Горутина — это легковесный поток выполнения в Go, который позволяет писать concurrent-код просто и эффективно. Горутины являются одной
    из ключевых особенностей Go, которые делают его мощным инструментом для создания многопоточных приложений. Они идеально подходят для задач,
    требующих параллельного выполнения, таких как обработка запросов, работа с сетью, обработка данных и многое другое.
    - Чем горутина отличается от треда?
    Горутина — это легковесный поток выполнения, управляемый runtime Go. Она является одной из ключевых особенностей языка Go.
        Основные характеристики:
    Легковесность:
    Горутины занимают очень мало памяти (начальный размер стека — около 2 КБ).
        Можно создавать миллионы горутин без значительных накладных расходов.
        Управление:
       Горутины управляются runtime Go, а не операционной системой.
        Они multiplexed (мультиплексируются) на небольшое количество потоков ОС (обычно равное количеству ядер процессора).
        Создание:
      Горутины создаются с помощью ключевого слова go. Например:
    go someFunction()
    Синхронизация:
       Горутины общаются через каналы (channels), что упрощает синхронизацию и передачу данных.
        Производительность:
       Горутины эффективно используют ресурсы процессора и подходят для высоконагруженных приложений.
       Поток — это единица выполнения, управляемая операционной системой. Потоки являются частью многопоточных программ в таких языках,
       как C++, Java, Python и других.
       Основные характеристики:
       Тяжеловесность:
             Потоки занимают значительно больше памяти (обычно 1 МБ или больше на поток).
              Количество потоков ограничено ресурсами системы (обычно тысячи).
              Управление:
             Потоки управляются операционной системой, что приводит к большим накладным расходам на создание и переключение контекста.
              Создание:
             Потоки создаются с помощью API операционной системы или библиотек (например, pthread в C, Thread в Java).
              Синхронизация:
              Потоки синхронизируются с помощью примитивов, таких как мьютексы, семафоры, условные переменные и т.д.
              Производительность:
              Переключение контекста между потоками дорогое, так как требует взаимодействия с ядром ОС.

Средне
-------------
    - В чем преимущества горутин над тредами?
    Легковесность: Занимают меньше памяти, можно создавать миллионы горутин.
        Быстрое создание и переключение: Управляются runtime Go, а не ОС.
        Простота использования: Синтаксис go и каналы делают concurrent-программирование простым и безопасным.
       Масштабируемость: Подходят для высоконагруженных приложений с высокой степенью параллелизма.
        Интеграция с каналами: Упрощают синхронизацию и передачу данных.
    - Что есть в Golang для многопоточности?
    Горутины для легковесного параллелизма.
        Каналы для безопасной передачи данных и синхронизации.
        Пакет sync для примитивов синхронизации.
        Пакет sync/atomic для атомарных операций.
        Пакет context для управления временем жизни горутин.
        Пакет golang.org/x/sync для дополнительных инструментов.

Редко
-------------
    - Зачем понадобилось добавлять горутины в Golang?
    Горутины были добавлены в Go для решения следующих проблем:
        Упрощение concurrent-программирования: Ключевое слово go и каналы делают код простым и безопасным.
        Легковесность и масштабируемость: Можно создавать миллионы горутин без значительных накладных расходов.
        Эффективное использование ресурсов процессора: Горутины управляются runtime Go, что минимизирует накладные расходы.
        Упрощение синхронизации: Каналы позволяют безопасно передавать данные между горутинами.
        Масштабируемость и производительность: Горутины идеальны для высоконагруженных приложений.
       Эти особенности делают Go мощным языком для создания concurrent- и parallel-приложений.
    - Как можно остановить горутину?
    Для корректной остановки горутины рекомендуется использовать:
        Каналы для передачи сигнала о завершении.
        context.Context для управления временем жизни горутин и передачи сигналов отмены.
    - Расскажите про конкуррентность и параллельность в Golang
    Конкурентность — это способ организации кода, при котором несколько задач выполняются псевдопараллельно, то есть они могут переключаться между
     собой, даже если физически выполняются на одном ядре процессора. Конкурентность связана с структурой программы и тем, как задачи разделяются
     и управляются.
     Пример в Go:
     Горутины позволяют писать конкурентный код. Например, несколько горутин могут выполняться одновременно, переключаясь между собой.
     Параллельность — это способ выполнения нескольких задач одновременно на нескольких ядрах процессора. Параллельность связана с физическим выполнением задач.
      Пример в Go:
     Если программа запущена на многоядерном процессоре, Go может распределить горутины по разным ядрам, чтобы они выполнялись параллельно.
    - Когда возникает утечка горутины?
    Утечка горутин возникает, когда горутина запускается, но никогда не завершается. Это может быть вызвано блокировкой на канале, бесконечным циклом, забытым WaitGroup или контекстом. Для предотвращения утечек:
        Используйте defer, тайм-ауты и context.Context.
        Регулярно тестируйте и профилируйте программу.
        Следите за количеством активных горутин с помощью runtime.NumGoroutine() и pprof.
        import _ "net/http/pprof"
        go func() {
            log.Println(http.ListenAndServe("localhost:6060", nil))
        }()
        или
        fmt.Println("Goroutines:", runtime.NumGoroutine())
    - Какие есть способы связи между горутинами, какие плюсы и минусы?
    Способы связи между горутинами в Go:
       Каналы (Channels):
    Плюсы: Безопасность, синхронизация, простота.
    Минусы: Блокировка, сложность для сложных сценариев.
       sync.Mutex / sync.RWMutex:
        Плюсы: Контроль доступа, простота.
        Минусы: Риск deadlock'ов, производительность.
        sync.WaitGroup:
        Плюсы: Простота, синхронизация.
        Минусы: Ограниченность (только для ожидания).
       sync/atomic:
       Плюсы: Производительность, простота.
        Минусы: Ограниченность (только для примитивов).
        context.Context:
       Плюсы: Управление жизненным циклом, гибкость.
       Минусы: Сложность.
    Итог:
      Для передачи данных и синхронизации — каналы и мьютексы.
       Для ожидания завершения — WaitGroup.
       Для управления жизненным циклом — context.
        Для атомарных операций — atomic.


==============================
    Интерфейсы
==============================
Часто
-------------
    - Что такое интерфейс?

Средне
-------------
    - Как устроен интерфейс?
    - Для чего используется интерфейс?

Редко
-------------
    - Как ты используешь интерфейс в работе?
    - Как в строготипизированным языке сделать функцию, которая работает с разными типами?
    - Зачем нужен пустой интерфейс?
    - Есть интерфейс, а есть указатель на структуру, который nil. Кладем указатель в интерфейс. Что если сравнить интерфейс с nil?
    - Чем `any` отличается от пустого интерфейса?
    - Чем пустой интерфейс отличается от пустой структуры?


==============================
    Общее
==============================

Средне
-------------
    - Какие преимущества есть у Golang?

Редко
-------------
    - Какие основные компоненты библиотеки runtime знаешь?
    - Какие недостатки есть у Golang?
    - Какие фреймворки знаешь для инициализации приложения?
    - Какая сортировка используется в Golang?
    - Какая последняя версия Golang?
    - Какая кодировка используется в Golang?
    - Расскажи про разные подходы инициализации приложения и какие сам используешь?
    - Можно ли в Golang создать статический метод?
    - Расскажи про пакет reflect и как его используешь?
    - Работали с библиотекой math? Что делает math.Pow?
    - При ручном биндинге (про инициализацию приложения) сталкивался с циклической зависимостью?
    - К каким проблемам может привести использование пакета reflect?
    - Как передаются параметры в функцию, по ссылке или по значению?
    - Для чего используется функция init?
    - В чем разница в передаче получателя метода по ссылке и по значению?
    - Вы нашли багу в Golang, вы можете как-то повлиять на исходный код, внести правки, сделать мерж реквест?
    - Чем тебе понравился Golang?
    - Что добавилось интересного с последней версией Golang?
    - Язык Golang компилируемый или интерпретируемый?


==============================
    Планировщик
==============================

Средне
-------------
    - Как работает планировщик Golang?

Редко
-------------
    - Как работает вытесняющая многозадачность?
    - За счет чего достигается параллельное выполнение в Golang? 
    - В чем разница между вытесняющим и кооперативным планировщиком? 
    - В планировщике до версии 1.15 какие операции приводят к переключению контекста горутин?
    - Можно ли руками переключить контекст горутины?
    - Может ли горутина начать работу на одном P, приостановиться и продолжить работу на другом P?
    - Может ли одна очередь украсть горутины у другой?
    - Расскажи про глобальную и локальную очереди
    - Сколько потоков операционной системы мы можем создать?
    - Какой тип планировщика в Golang?
    - Какую функцию выполняет планировщик?
    - Что происходит с горутиной при ее создании?


==============================
    Контекст
==============================
Часто
-------------
    - Для чего используется контекст?

Средне
-------------
    - Что такое контекст?

Редко
-------------
    - Как работает WithCancel?
    - Как применяешь контекст в работе?
    - Как устроен контекст?
    - Какие есть виды контекстов?
    - Перекидывали логгер в контексте?


==============================
    defer
==============================
Часто
-------------
    - Что такое defer?

Средне
-------------
    - Для чего используется defer?
    - Какой порядок выполнения нескольких defer?

Редко
-------------
    - Код в defer выполняется до return или после?
    - Где инициализируется defer, в стеке или куче?


==============================
    Память
==============================

Редко
-------------
    - В одном случае ты передаешь указатель на допустим инт, а в другом случае большую структурку. Как с точки зрения рантайма и потребления ресурсов будет вести приложение?
    - Как узнать где выделяется переменная, в стеке или куче?
    - Как можно обнаружить чересчур большое выделение памяти?
    - Предположим есть рекурсивная функция. Вызывается много раз. Что может произойти?
    - Расскажи про модель памяти в Golang, про стек и про кучу
    - Какое максимальный размер значения для размещения в стеке?
    - Что такое Escape Analysis?
    - Что если при увеличении слайса полностью забьем память?
    - Что быстрее, размещение объектов в стеке или куче и почему?
    - Что такое утечка памяти?
    - Что такое стек?


==============================
    Типы данных
==============================

Средне
-------------
    - Какие типы данных есть в Golang?

Редко
-------------
    - Какой длины руна?
    - Как реализовать Enum в Golang?
    - Если нужно в строке хранить эмодзи, то как это сделать? 
    - Что если во время компиляции переполним тип? В int8 запишем  256?
    - Что происходит при переполнении числа, например в uint8 выйдем за границу на 1?


==============================
    Гонка данных
==============================

Средне
-------------
    - Что такое race condition?
    - Как обнаружить race condition?

Редко
-------------
    - Есть глобальный слайс и я в разных горутинах присваиваю ему аппенд к нему же одного элемента. Будет ли гонка?
    - Где кроме кода может встретиться race condition?
    - Какие есть способы устранения race condition?
    - Флаг -race показывает гонку на этапе компиляции или выполнения?


==============================
    Ошибки/Паника
==============================

Редко
-------------
    - Куда нужно помещать recover?
    - Какая парадигма в Golang с точки зрения обработки исключений и ошибок?
    - Какие есть функции для оборачивания и сравнения ошибок?
    - Для чего используются ошибки, а для чего паника?
    - Для чего используется паника?
    - Есть несколько деферов, в одном из них рековер. Как будет обрабатываться паника? Что если рековер расположен сильно выше и куда бы ты его поместил в случае http вызова? Есть несколько деферов и в одном из них паника, рековер нет, что будет?
    - Что используется для обработки паники?
    - Чем отличается работа с ошибками в Golang от других языков?
    - Что такое паника?


==============================
    Указатели
==============================

Средне
-------------
    - Что такое указатель?

Редко
-------------
    - Что такое ссылка на значение?
    - Чем отличается ссылка от указателя?
    - Чем чревато передавать структуру по ссылке?
    - Для чего используются указатели?
    - Для чего в практике используешь указатели?
    - Какие есть средства для работы с указателями?
    - Когда лучше использовать/не использовать указатели?


==============================
    Дженерики
==============================

Средне
-------------
    - С дженериками работали?

Редко
-------------
    - Чем кодогенерация отличается от дженериков?
    - В какой версии появились дженерики?


==============================
    Конструкции
==============================

Редко
-------------
    - Гарантирует ли порядок выполнения конструкция select-case?
    - Как выглядит конструкция утверждения типа switch?
    - Нужно ли в switch-case проставлять break?
    - Какие есть циклы в Golang?
    - Чем отличается switch от select?


==============================
    ООП
==============================

Средне
-------------
    - Как устроено ООП в Golang?
    - Как реализуется наследование в Golang?


==============================
    Сборщик мусора
==============================

Редко
-------------
    - Как приходилось работать со сборкой мусора?
    - Как работает GC, его алгоритм и когда запускается?
    - Вот выделилась память и она используется, зачем в таком случае нужен GC?
    - Для чего используется GC?
    - Какие есть рекомандации как упростить жизнь GC?
    - Можно ли как-то отключить GC или ограничить запуски?
    - Что такое GC?
    - Что такое сборка мусора?


==============================
    Строки
==============================

Средне
-------------
    - Что такое string?

Редко
-------------
    - Приходит строка в utf8, там могут быть русские символы. Как узнать есть ли там русские буквы икак узнать длину в символах?
    - Какие особенности есть у string?
    - Как работать с utf8 строкой?


==============================
    Структуры
==============================

Редко
-------------
    - Имеет ли значение порядок полей в структуре?
    - От чего зависит размер выравнивания в структуре?
    - Что такое структура?


==============================
    Пакеты
==============================

Редко
-------------
    - Что такое пакет?
    - Расскажи про папку internal
